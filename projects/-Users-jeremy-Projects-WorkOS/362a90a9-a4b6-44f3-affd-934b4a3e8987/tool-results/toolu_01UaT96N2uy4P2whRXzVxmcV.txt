     1→import { NextResponse } from "next/server"
     2→import { getDb } from "@/lib/db"
     3→import { clientMemory, clients, moves } from "@/lib/schema"
     4→import { eq, and, gte, sql } from "drizzle-orm"
     5→
     6→export async function GET() {
     7→  try {
     8→    const db = getDb()
     9→
    10→    // Get current time in EST
    11→    const now = new Date()
    12→    const estOffset = -5 * 60
    13→    const estNow = new Date(now.getTime() + (now.getTimezoneOffset() + estOffset) * 60000)
    14→
    15→    // Week start (Monday)
    16→    const weekStart = new Date(estNow)
    17→    weekStart.setDate(weekStart.getDate() - weekStart.getDay() + (weekStart.getDay() === 0 ? -6 : 1))
    18→    weekStart.setHours(0, 0, 0, 0)
    19→
    20→    // Get all active clients
    21→    const allClients = await db.select().from(clients).where(eq(clients.isActive, 1))
    22→
    23→    // Get all client memory entries
    24→    const allMemory = await db.select().from(clientMemory)
    25→
    26→    const weeklyMoves = await db
    27→      .select({
    28→        clientId: moves.clientId,
    29→        count: sql<number>`COUNT(*)`.as("count"),
    30→      })
    31→      .from(moves)
    32→      .where(and(eq(moves.status, "done"), gte(moves.completedAt, weekStart)))
    33→      .groupBy(moves.clientId)
    34→
    35→    const weeklyMovesMap = new Map(weeklyMoves.map((w) => [w.clientId, Number(w.count)]))
    36→
    37→    const lastActivity = await db
    38→      .select({
    39→        clientId: moves.clientId,
    40→        lastCompletion: sql<Date>`MAX(${moves.completedAt})`.as("lastCompletion"),
    41→      })
    42→      .from(moves)
    43→      .where(eq(moves.status, "done"))
    44→      .groupBy(moves.clientId)
    45→
    46→    const lastActivityMap = new Map(lastActivity.map((l) => [l.clientId, l.lastCompletion]))
    47→
    48→    // Merge clients with their memory settings and stats
    49→    const clientsWithMemory = allClients.map((client) => {
    50→      const memory = allMemory.find((m) => m.clientName === client.name)
    51→      const movesThisWeek = weeklyMovesMap.get(client.id) || 0
    52→      const lastCompletedAt = lastActivityMap.get(client.id)
    53→
    54→      // Calculate days since last activity
    55→      let daysSinceActivity: number | null = null
    56→      if (lastCompletedAt) {
    57→        daysSinceActivity = Math.floor((Date.now() - new Date(lastCompletedAt).getTime()) / (1000 * 60 * 60 * 24))
    58→      }
    59→
    60→      return {
    61→        clientId: client.id,
    62→        clientName: client.name,
    63→        color: client.color,
    64→        // Memory fields with defaults
    65→        tier: memory?.tier || "active",
    66→        sentiment: memory?.sentiment || "neutral",
    67→        importance: memory?.importance || "medium",
    68→        notes: memory?.notes || "",
    69→        avoidanceScore: memory?.avoidanceScore || 0,
    70→        preferredWorkTime: memory?.preferredWorkTime || null,
    71→        movesThisWeek,
    72→        lastCompletedAt: lastCompletedAt ? new Date(lastCompletedAt).toISOString() : null,
    73→        daysSinceActivity,
    74→      }
    75→    })
    76→
    77→    return NextResponse.json(clientsWithMemory)
    78→  } catch (error) {
    79→    console.error("[v0] Client memory GET error:", error)
    80→    return NextResponse.json({ error: "Failed to fetch client memory" }, { status: 500 })
    81→  }
    82→}
    83→
    84→export async function PUT(request: Request) {
    85→  try {
    86→    const db = getDb()
    87→    const body = await request.json()
    88→    const { clientName, tier, sentiment, importance, notes, avoidanceScore, preferredWorkTime } = body
    89→
    90→    if (!clientName) {
    91→      return NextResponse.json({ error: "clientName is required" }, { status: 400 })
    92→    }
    93→
    94→    // Check if memory entry exists
    95→    const [existing] = await db.select().from(clientMemory).where(eq(clientMemory.clientName, clientName))
    96→
    97→    const updateData = {
    98→      tier,
    99→      sentiment,
   100→      importance,
   101→      notes,
   102→      avoidanceScore,
   103→      preferredWorkTime,
   104→      updatedAt: new Date(),
   105→    }
   106→
   107→    if (existing) {
   108→      // Update existing
   109→      const [updated] = await db
   110→        .update(clientMemory)
   111→        .set(updateData)
   112→        .where(eq(clientMemory.clientName, clientName))
   113→        .returning()
   114→      return NextResponse.json(updated)
   115→    } else {
   116→      // Create new entry
   117→      const [created] = await db
   118→        .insert(clientMemory)
   119→        .values({
   120→          id: crypto.randomUUID(),
   121→          clientName,
   122→          ...updateData,
   123→          createdAt: new Date(),
   124→        })
   125→        .returning()
   126→      return NextResponse.json(created)
   127→    }
   128→  } catch (error) {
   129→    console.error("[v0] Client memory PUT error:", error)
   130→    return NextResponse.json({ error: "Failed to update client memory" }, { status: 500 })
   131→  }
   132→}
   133→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

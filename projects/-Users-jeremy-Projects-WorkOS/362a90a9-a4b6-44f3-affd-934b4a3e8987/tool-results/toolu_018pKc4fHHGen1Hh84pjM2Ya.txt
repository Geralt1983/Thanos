     1→import { getDb } from "./db"
     2→import { taskEvents, clientMemory, tasks, clients } from "./schema"
     3→import { eq, sql } from "drizzle-orm"
     4→
     5→export type EventType = "created" | "promoted" | "demoted" | "completed" | "deferred" | "reopened" | "edited"
     6→
     7→interface LogEventParams {
     8→  taskId: number
     9→  eventType: EventType
    10→  fromStatus?: string
    11→  toStatus?: string
    12→  metadata?: Record<string, any>
    13→}
    14→
    15→export async function logTaskEvent({ taskId, eventType, fromStatus, toStatus, metadata = {} }: LogEventParams) {
    16→  try {
    17→    const db = await getDb()
    18→
    19→    // Log the event
    20→    await db.insert(taskEvents).values({
    21→      taskId,
    22→      eventType,
    23→      fromStatus,
    24→      toStatus,
    25→      metadata,
    26→    })
    27→
    28→    // Get the task to find its client
    29→    const [task] = await db
    30→      .select({
    31→        id: tasks.id,
    32→        clientId: tasks.clientId,
    33→      })
    34→      .from(tasks)
    35→      .where(eq(tasks.id, taskId))
    36→      .limit(1)
    37→
    38→    if (!task?.clientId) return
    39→
    40→    // Get the client name
    41→    const [client] = await db.select({ name: clients.name }).from(clients).where(eq(clients.id, task.clientId)).limit(1)
    42→
    43→    if (!client) return
    44→
    45→    // If this is a deferral, increment the avoidance score for the client
    46→    if (eventType === "deferred" || eventType === "demoted") {
    47→      await db
    48→        .update(clientMemory)
    49→        .set({
    50→          avoidanceScore: sql`COALESCE(avoidance_score, 0) + 1`,
    51→          updatedAt: new Date(),
    52→        })
    53→        .where(eq(clientMemory.clientName, client.name))
    54→    }
    55→
    56→    // If completed, update client memory
    57→    if (eventType === "completed") {
    58→      await db
    59→        .update(clientMemory)
    60→        .set({
    61→          lastTaskAt: new Date(),
    62→          totalTasks: sql`COALESCE(total_tasks, 0) + 1`,
    63→          staleDays: 0,
    64→          updatedAt: new Date(),
    65→        })
    66→        .where(eq(clientMemory.clientName, client.name))
    67→    }
    68→  } catch (err) {
    69→    console.error("[events] Failed to log task event:", err)
    70→  }
    71→}
    72→
    73→// Legacy alias
    74→export const logMoveEvent = (params: { moveId: number; eventType: EventType; fromStatus?: string; toStatus?: string; metadata?: Record<string, any> }) => {
    75→  return logTaskEvent({ ...params, taskId: params.moveId })
    76→}
    77→
    78→// Get event history for a task
    79→export async function getTaskHistory(taskId: number) {
    80→  try {
    81→    const db = await getDb()
    82→    return db.select().from(taskEvents).where(eq(taskEvents.taskId, taskId)).orderBy(taskEvents.createdAt)
    83→  } catch (err) {
    84→    console.error("[events] Failed to get task history:", err)
    85→    return []
    86→  }
    87→}
    88→
    89→// Legacy alias
    90→export const getMoveHistory = getTaskHistory
    91→
    92→// Count deferrals for a specific task
    93→export async function getDeferralCount(taskId: number): Promise<number> {
    94→  try {
    95→    const db = await getDb()
    96→    const events = await db.select().from(taskEvents).where(eq(taskEvents.taskId, taskId))
    97→
    98→    return events.filter((e) => e.eventType === "deferred" || e.eventType === "demoted").length
    99→  } catch (err) {
   100→    console.error("[events] Failed to get deferral count:", err)
   101→    return 0
   102→  }
   103→}
   104→
   105→// Determine event type from status change
   106→export function determineEventType(fromStatus: string | undefined, toStatus: string): EventType {
   107→  if (!fromStatus) return "created"
   108→  if (toStatus === "done") return "completed"
   109→  if (fromStatus === "done") return "reopened"
   110→
   111→  const statusPriority: Record<string, number> = {
   112→    active: 4,
   113→    queued: 3,
   114→    backlog: 2,
   115→    done: 1,
   116→  }
   117→
   118→  const fromPriority = statusPriority[fromStatus] ?? 0
   119→  const toPriority = statusPriority[toStatus] ?? 0
   120→
   121→  if (toPriority > fromPriority) return "promoted"
   122→  if (toPriority < fromPriority) return "demoted"
   123→  return "edited"
   124→}
   125→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

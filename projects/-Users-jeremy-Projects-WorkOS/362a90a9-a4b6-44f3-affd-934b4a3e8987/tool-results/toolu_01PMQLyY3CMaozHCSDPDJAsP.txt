     1→import { NextResponse } from "next/server"
     2→import { getDb } from "@/lib/db"
     3→import { moves, clients, clientMemory } from "@/lib/schema"
     4→import { eq, asc, and, gte } from "drizzle-orm"
     5→
     6→interface BacklogTask {
     7→  id: number
     8→  title: string
     9→  drainType: string | null
    10→  effortEstimate: number | null
    11→  daysInBacklog: number
    12→  decayStatus: "normal" | "aging" | "stale" | "critical"
    13→}
    14→
    15→interface ClientGroup {
    16→  clientId: number
    17→  clientName: string
    18→  clientColor: string
    19→  staleDays: number
    20→  touchedToday: boolean
    21→  tasks: BacklogTask[]
    22→}
    23→
    24→export async function GET() {
    25→  try {
    26→    const db = getDb()
    27→
    28→    // Get all backlog moves grouped by client
    29→    const backlogMoves = await db
    30→      .select({
    31→        id: moves.id,
    32→        title: moves.title,
    33→        clientId: moves.clientId,
    34→        drainType: moves.drainType,
    35→        effortEstimate: moves.effortEstimate,
    36→        createdAt: moves.createdAt,
    37→        sortOrder: moves.sortOrder,
    38→        clientName: clients.name,
    39→        clientColor: clients.color,
    40→      })
    41→      .from(moves)
    42→      .leftJoin(clients, eq(moves.clientId, clients.id))
    43→      .where(eq(moves.status, "backlog"))
    44→      .orderBy(asc(moves.sortOrder))
    45→
    46→    // Get client memory for stale days
    47→    const memories = await db.select().from(clientMemory)
    48→    const memoryMap = new Map(memories.map((m) => [m.clientName, m]))
    49→
    50→    // Check what was touched today (EST)
    51→    const now = new Date()
    52→    const estOffset = -5 * 60
    53→    const estNow = new Date(now.getTime() + (now.getTimezoneOffset() + estOffset) * 60000)
    54→    const todayStart = new Date(estNow)
    55→    todayStart.setHours(0, 0, 0, 0)
    56→
    57→    const todayMoves = await db
    58→      .select({
    59→        clientName: clients.name,
    60→      })
    61→      .from(moves)
    62→      .leftJoin(clients, eq(moves.clientId, clients.id))
    63→      .where(and(eq(moves.status, "done"), gte(moves.completedAt, todayStart)))
    64→
    65→    const touchedToday = new Set(todayMoves.map((m) => m.clientName))
    66→
    67→    // Group by client
    68→    const grouped = new Map<number, ClientGroup>()
    69→
    70→    for (const move of backlogMoves) {
    71→      if (!move.clientId) continue
    72→
    73→      const clientId = move.clientId
    74→
    75→      if (!grouped.has(clientId)) {
    76→        const memory = memoryMap.get(move.clientName || "")
    77→        grouped.set(clientId, {
    78→          clientId,
    79→          clientName: move.clientName || "Unknown",
    80→          clientColor: move.clientColor || "#6b7280",
    81→          staleDays: memory?.staleDays || 0,
    82→          touchedToday: touchedToday.has(move.clientName),
    83→          tasks: [],
    84→        })
    85→      }
    86→
    87→      const daysInBacklog = Math.floor((Date.now() - new Date(move.createdAt).getTime()) / (1000 * 60 * 60 * 24))
    88→
    89→      let decayStatus: BacklogTask["decayStatus"] = "normal"
    90→      if (daysInBacklog >= 21) decayStatus = "critical"
    91→      else if (daysInBacklog >= 14) decayStatus = "stale"
    92→      else if (daysInBacklog >= 7) decayStatus = "aging"
    93→
    94→      grouped.get(clientId)!.tasks.push({
    95→        id: move.id,
    96→        title: move.title,
    97→        drainType: move.drainType,
    98→        effortEstimate: move.effortEstimate,
    99→        daysInBacklog,
   100→        decayStatus,
   101→      })
   102→    }
   103→
   104→    // Convert to array and sort by stale days (most stale first)
   105→    const result = Array.from(grouped.values()).sort((a, b) => {
   106→      // Touched today goes last
   107→      if (a.touchedToday && !b.touchedToday) return 1
   108→      if (!a.touchedToday && b.touchedToday) return -1
   109→      // Then by stale days
   110→      return b.staleDays - a.staleDays
   111→    })
   112→
   113→    return NextResponse.json({
   114→      groups: result,
   115→      totalTasks: backlogMoves.length,
   116→    })
   117→  } catch (error) {
   118→    console.error("Failed to get grouped backlog:", error)
   119→    return NextResponse.json({ error: "Failed to get grouped backlog" }, { status: 500 })
   120→  }
   121→}
   122→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

     1→import { NextResponse } from "next/server"
     2→import { getDb } from "@/lib/db"
     3→import { moves, clients, clientMemory } from "@/lib/schema"
     4→import { eq, and, gte, sql } from "drizzle-orm"
     5→
     6→interface ScoredMove {
     7→  id: number
     8→  title: string
     9→  clientId: number | null
    10→  clientName: string | null
    11→  clientColor: string | null
    12→  drainType: string | null
    13→  effortEstimate: number | null
    14→  createdAt: Date
    15→  score: number
    16→  reason: string
    17→  daysInBacklog: number
    18→}
    19→
    20→function getPreferredDrainTypes(hour: number): { types: string[]; label: string } {
    21→  if (hour < 11) return { types: ["deep"], label: "morning deep work time" }
    22→  if (hour < 14) return { types: ["shallow", "admin"], label: "midday communication time" }
    23→  return { types: ["shallow", "admin"], label: "afternoon wind-down" }
    24→}
    25→
    26→export async function GET() {
    27→  try {
    28→    const db = getDb()
    29→
    30→    // Get current time in EST
    31→    const now = new Date()
    32→    const estOffset = -5 * 60
    33→    const estNow = new Date(now.getTime() + (now.getTimezoneOffset() + estOffset) * 60000)
    34→    const todayStart = new Date(estNow)
    35→    todayStart.setHours(0, 0, 0, 0)
    36→
    37→    const weekStart = new Date(estNow)
    38→    weekStart.setDate(weekStart.getDate() - weekStart.getDay() + (weekStart.getDay() === 0 ? -6 : 1))
    39→    weekStart.setHours(0, 0, 0, 0)
    40→
    41→    // Get all backlog moves with client info
    42→    const backlogMoves = await db
    43→      .select({
    44→        id: moves.id,
    45→        title: moves.title,
    46→        clientId: moves.clientId,
    47→        drainType: moves.drainType,
    48→        effortEstimate: moves.effortEstimate,
    49→        createdAt: moves.createdAt,
    50→        backlogEnteredAt: moves.backlogEnteredAt,
    51→        clientName: clients.name,
    52→        clientColor: clients.color,
    53→      })
    54→      .from(moves)
    55→      .leftJoin(clients, eq(moves.clientId, clients.id))
    56→      .where(eq(moves.status, "backlog"))
    57→
    58→    const allClientMemory = await db.select().from(clientMemory)
    59→    const memoryMap = new Map(allClientMemory.map((m) => [m.clientName, m]))
    60→
    61→    const clientLastCompletion = await db
    62→      .select({
    63→        clientId: moves.clientId,
    64→        lastCompletion: sql<Date>`MAX(${moves.completedAt})`.as("lastCompletion"),
    65→      })
    66→      .from(moves)
    67→      .where(eq(moves.status, "done"))
    68→      .groupBy(moves.clientId)
    69→
    70→    const clientLastCompletionMap = new Map(clientLastCompletion.map((c) => [c.clientId, c.lastCompletion]))
    71→
    72→    const weeklyClientCompletions = await db
    73→      .select({
    74→        clientId: moves.clientId,
    75→        count: sql<number>`COUNT(*)`.as("count"),
    76→      })
    77→      .from(moves)
    78→      .where(and(eq(moves.status, "done"), gte(moves.completedAt, weekStart)))
    79→      .groupBy(moves.clientId)
    80→
    81→    const weeklyCompletionMap = new Map(weeklyClientCompletions.map((c) => [c.clientId, Number(c.count)]))
    82→
    83→    const todayDrainTypes = await db
    84→      .select({
    85→        drainType: moves.drainType,
    86→      })
    87→      .from(moves)
    88→      .where(and(eq(moves.status, "done"), gte(moves.completedAt, todayStart)))
    89→
    90→    const usedDrainTypesToday = new Set(todayDrainTypes.map((m) => m.drainType).filter(Boolean))
    91→
    92→    // Get clients with completions today
    93→    const todayMoves = await db
    94→      .select({
    95→        clientId: moves.clientId,
    96→        clientName: clients.name,
    97→      })
    98→      .from(moves)
    99→      .leftJoin(clients, eq(moves.clientId, clients.id))
   100→      .where(and(eq(moves.status, "done"), gte(moves.completedAt, todayStart)))
   101→
   102→    const touchedTodayClientIds = new Set(todayMoves.map((m) => m.clientId))
   103→
   104→    // Current hour for energy matching (EST)
   105→    const hour = estNow.getHours()
   106→    const { types: preferredDrainTypes, label: timeLabel } = getPreferredDrainTypes(hour)
   107→
   108→    const scored: ScoredMove[] = backlogMoves.map((move) => {
   109→      const clientName = move.clientName || "Unknown"
   110→      const clientId = move.clientId
   111→
   112→      // Calculate days in backlog (use backlogEnteredAt if available)
   113→      const backlogDate = move.backlogEnteredAt || move.createdAt
   114→      const daysInBacklog = Math.floor((Date.now() - new Date(backlogDate).getTime()) / (1000 * 60 * 60 * 24))
   115→
   116→      let score = 0
   117→      const reasons: string[] = []
   118→
   119→      const memory = clientName ? memoryMap.get(clientName) : null
   120→      const clientImportance = memory?.importance || "medium"
   121→      const clientSentiment = memory?.sentiment || "neutral"
   122→
   123→      if (clientImportance === "high") {
   124→        score += 20
   125→        reasons.push(`${clientName} is high priority`)
   126→      } else if (clientImportance === "low") {
   127→        score -= 10
   128→      }
   129→
   130→      if (clientSentiment === "challenging") {
   131→        score += 15
   132→        reasons.push(`${clientName} needs attention (concerned sentiment)`)
   133→      }
   134→
   135→      // 1. CLIENT COMPLETION RECENCY (weight: 25 max)
   136→      const lastCompletion = clientId ? clientLastCompletionMap.get(clientId) : null
   137→      if (lastCompletion) {
   138→        const daysSinceCompletion = Math.floor(
   139→          (Date.now() - new Date(lastCompletion).getTime()) / (1000 * 60 * 60 * 24),
   140→        )
   141→        if (daysSinceCompletion >= 1) {
   142→          const recencyScore = Math.min(daysSinceCompletion * 5, 25)
   143→          score += recencyScore
   144→          if (daysSinceCompletion >= 3) {
   145→            reasons.push(`${clientName} hasn't been touched in ${daysSinceCompletion} days`)
   146→          }
   147→        }
   148→      } else if (clientId) {
   149→        score += 25
   150→        reasons.push(`${clientName} has no completions yet`)
   151→      }
   152→
   153→      // 2. WEEKLY CLIENT COVERAGE (weight: 20 max)
   154→      const weeklyCount = clientId ? weeklyCompletionMap.get(clientId) || 0 : 0
   155→      if (weeklyCount === 0) {
   156→        score += 20
   157→        reasons.push(`${clientName} has 0 moves this week`)
   158→      } else if (weeklyCount === 1) {
   159→        score += 10
   160→      }
   161→
   162→      // 3. DRAIN TYPE BALANCE (weight: 15)
   163→      if (move.drainType && !usedDrainTypesToday.has(move.drainType)) {
   164→        score += 15
   165→        reasons.push(`No ${move.drainType} work done today`)
   166→      }
   167→
   168→      // 4. ENERGY-TIME MATCH (weight: 15)
   169→      const energyMatch = preferredDrainTypes.includes(move.drainType || "")
   170→      if (energyMatch) {
   171→        score += 15
   172→        if (!reasons.some((r) => r.includes(move.drainType || ""))) {
   173→          reasons.push(`${move.drainType} work fits ${timeLabel}`)
   174→        }
   175→      }
   176→
   177→      // 5. BACKLOG AGE (weight: 10 max)
   178→      const ageScore = Math.min(daysInBacklog, 10)
   179→      score += ageScore
   180→      if (daysInBacklog >= 14) {
   181→        reasons.push(`${daysInBacklog} days in backlog`)
   182→      }
   183→
   184→      // 6. QUICK WIN BONUS (weight: 10)
   185→      if (move.effortEstimate === 1) {
   186→        score += 10
   187→        reasons.push("Quick win to build momentum")
   188→      }
   189→
   190→      // 7. CLIENT ALREADY TOUCHED TODAY (penalty: -30)
   191→      if (clientId && touchedTodayClientIds.has(clientId)) {
   192→        score -= 30
   193→      }
   194→
   195→      // 8. SMALL RANDOM FACTOR (0-5)
   196→      score += Math.random() * 5
   197→
   198→      return {
   199→        id: move.id,
   200→        title: move.title,
   201→        clientId: move.clientId,
   202→        clientName: move.clientName,
   203→        clientColor: move.clientColor,
   204→        drainType: move.drainType,
   205→        effortEstimate: move.effortEstimate,
   206→        createdAt: move.createdAt,
   207→        score: Math.round(score * 10) / 10,
   208→        reason: reasons.length > 0 ? reasons[0] : "Good next candidate",
   209→        daysInBacklog,
   210→      }
   211→    })
   212→
   213→    // Sort by score, take top picks, ensure client diversity
   214→    const sorted = scored.sort((a, b) => b.score - a.score)
   215→    const recommendations: ScoredMove[] = []
   216→    const usedClients = new Set<number | null>()
   217→
   218→    for (const item of sorted) {
   219→      if (recommendations.length >= 3) break
   220→      if (item.clientId && usedClients.has(item.clientId)) {
   221→        continue
   222→      }
   223→      recommendations.push(item)
   224→      if (item.clientId) usedClients.add(item.clientId)
   225→    }
   226→
   227→    return NextResponse.json({
   228→      recommendations: recommendations.map((r) => ({
   229→        id: r.id,
   230→        title: r.title,
   231→        clientName: r.clientName,
   232→        clientColor: r.clientColor,
   233→        drainType: r.drainType,
   234→        effortEstimate: r.effortEstimate,
   235→        reason: r.reason,
   236→        score: r.score,
   237→        daysInBacklog: r.daysInBacklog,
   238→      })),
   239→    })
   240→  } catch (error) {
   241→    console.error("Failed to get recommendations:", error)
   242→    return NextResponse.json({ error: "Failed to get recommendations" }, { status: 500 })
   243→  }
   244→}
   245→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

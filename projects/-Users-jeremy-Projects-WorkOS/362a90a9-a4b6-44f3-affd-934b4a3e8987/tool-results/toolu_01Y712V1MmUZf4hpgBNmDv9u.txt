     1→"use client"
     2→
     3→import useSWR, { mutate as globalMutate } from "swr"
     4→import { MOCK_CLIENTS, MOCK_TASKS, isPreviewEnvironment } from "@/lib/mock-data"
     5→import { trackCompletedTask } from "@/hooks/use-metrics"
     6→import { apiFetch, SWR_CONFIG } from "@/lib/fetch-utils"
     7→
     8→// =============================================================================
     9→// TYPE DEFINITIONS
    10→// =============================================================================
    11→export type BackendTaskStatus = "active" | "queued" | "backlog" | "done"
    12→export type TaskStatus = "today" | "upnext" | "backlog" | "done"
    13→
    14→interface BackendTask {
    15→  id: number
    16→  clientId: number | null
    17→  title: string
    18→  description: string | null
    19→  status: BackendTaskStatus
    20→  effortEstimate: number | null
    21→  effortActual: number | null
    22→  drainType: string | null
    23→  sortOrder: number | null
    24→  subtasks?: Subtask[] | null
    25→  createdAt: string
    26→  updatedAt: string
    27→  completedAt: string | null
    28→  clientName?: string
    29→  client?: { id: number; name: string; color: string | null }
    30→  pointsAiGuess?: number | null
    31→  pointsFinal?: number | null
    32→  pointsAdjustedAt?: string | null
    33→}
    34→
    35→export interface Task {
    36→  id: string
    37→  client: string
    38→  clientId?: number
    39→  clientColor?: string
    40→  title: string
    41→  description?: string
    42→  type: "Quick" | "Standard" | "Chunky" | "Deep"
    43→  effortEstimate?: number
    44→  status: TaskStatus
    45→  subtasks?: Subtask[]
    46→  tasksCount?: number
    47→  ageLabel?: string
    48→  completedAt?: number
    49→  sortOrder?: number
    50→  drainType?: string
    51→  points?: number // Final points (user-adjusted or AI guess)
    52→  pointsAiGuess?: number
    53→  pointsFinal?: number
    54→}
    55→
    56→// Legacy alias
    57→export type Move = Task
    58→export type MoveStatus = TaskStatus
    59→export type BackendMoveStatus = BackendTaskStatus
    60→
    61→export interface Subtask {
    62→  id: string
    63→  title: string
    64→  completed: boolean
    65→}
    66→
    67→// =============================================================================
    68→// STATUS MAPPING
    69→// =============================================================================
    70→const statusToFrontend: Record<BackendTaskStatus, TaskStatus> = {
    71→  active: "today",
    72→  queued: "upnext",
    73→  backlog: "backlog",
    74→  done: "done",
    75→}
    76→
    77→const statusToBackend: Record<TaskStatus, BackendTaskStatus> = {
    78→  today: "active",
    79→  upnext: "queued",
    80→  backlog: "backlog",
    81→  done: "done",
    82→}
    83→
    84→const EFFORT_TO_TYPE: Record<number, Task["type"]> = {
    85→  1: "Quick",
    86→  2: "Standard",
    87→  3: "Chunky",
    88→  4: "Deep",
    89→}
    90→
    91→function effortToType(effort: number | null): Task["type"] {
    92→  return effort ? (EFFORT_TO_TYPE[effort] ?? "Standard") : "Standard"
    93→}
    94→
    95→function getAgeLabel(createdAt: string): string {
    96→  const created = new Date(createdAt)
    97→  const now = new Date()
    98→  const diffMs = now.getTime() - created.getTime()
    99→  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))
   100→
   101→  if (diffDays === 0) return "today"
   102→  if (diffDays === 1) return "1d ago"
   103→  if (diffDays < 7) return `${diffDays}d ago`
   104→  if (diffDays < 30) return `${Math.floor(diffDays / 7)}w ago`
   105→  return `${Math.floor(diffDays / 30)}mo ago`
   106→}
   107→
   108→// =============================================================================
   109→// MOCK MODE HELPERS
   110→// =============================================================================
   111→function shouldUseMockMode(): boolean {
   112→  return isPreviewEnvironment()
   113→}
   114→
   115→function mergeWithMockData<T extends { id: number }>(realData: T[] | null | undefined, mockData: T[]): T[] {
   116→  const isPreview = isPreviewEnvironment()
   117→  const hasRealData = Array.isArray(realData) && realData.length > 0
   118→
   119→  if (!isPreview) return realData || []
   120→  if (hasRealData) return realData
   121→
   122→  return mockData
   123→}
   124→
   125→// =============================================================================
   126→// LOCAL STATE FOR PREVIEW MODE
   127→// =============================================================================
   128→let localTasks: Task[] = []
   129→
   130→function getLocalTasks(): Task[] {
   131→  return localTasks
   132→}
   133→
   134→function addLocalTask(task: Task) {
   135→  localTasks = [task, ...localTasks]
   136→}
   137→
   138→function updateLocalTask(id: string, updates: Partial<Task>) {
   139→  localTasks = localTasks.map((t) => (t.id === id ? { ...t, ...updates } : t))
   140→}
   141→
   142→function removeLocalTask(id: string) {
   143→  localTasks = localTasks.filter((t) => t.id !== id)
   144→}
   145→
   146→// =============================================================================
   147→// TASKS HOOK
   148→// =============================================================================
   149→const TASKS_KEY = "tasks"
   150→
   151→export function useTasks() {
   152→  const { data, error, isLoading, mutate } = useSWR<Task[]>(
   153→    TASKS_KEY,
   154→    async () => {
   155→      let backendTasks: BackendTask[] = []
   156→      try {
   157→        backendTasks = await apiFetch<BackendTask[]>("/api/tasks")
   158→      } catch (err) {
   159→        console.log("[v0] useTasks: API error, will use mock data if in preview", err)
   160→      }
   161→
   162→      const tasksToUse = mergeWithMockData(backendTasks, MOCK_TASKS as any)
   163→
   164→      const mappedTasks = tasksToUse.map((task) => ({
   165→        id: task.id.toString(),
   166→        client: task.clientName ?? (task.client ? task.client.name : ""),
   167→        clientId: task.clientId ?? undefined,
   168→        clientColor: task.client?.color ?? undefined,
   169→        title: task.title,
   170→        description: task.description ?? undefined,
   171→        type: effortToType(task.effortEstimate),
   172→        effortEstimate: task.effortEstimate ?? 2,
   173→        status: statusToFrontend[task.status],
   174→        subtasks: (task.subtasks as Subtask[]) ?? [],
   175→        tasksCount: undefined,
   176→        ageLabel: getAgeLabel(task.createdAt),
   177→        completedAt: task.completedAt ? new Date(task.completedAt).getTime() : undefined,
   178→        sortOrder: task.sortOrder ?? undefined,
   179→        drainType: task.drainType ?? undefined,
   180→        points: task.pointsFinal ?? task.pointsAiGuess ?? undefined,
   181→        pointsAiGuess: task.pointsAiGuess ?? undefined,
   182→        pointsFinal: task.pointsFinal ?? undefined,
   183→      }))
   184→
   185→      if (isPreviewEnvironment()) {
   186→        const localTasksData = getLocalTasks()
   187→        const apiTaskIds = new Set(mappedTasks.map((t) => t.id))
   188→        const uniqueLocalTasks = localTasksData.filter((t) => !apiTaskIds.has(t.id))
   189→        return [...uniqueLocalTasks, ...mappedTasks]
   190→      }
   191→
   192→      return mappedTasks
   193→    },
   194→    SWR_CONFIG.default,
   195→  )
   196→
   197→  const tasks = data ?? []
   198→
   199→  const byStatus = (status: TaskStatus) => tasks.filter((t) => t.status === status)
   200→
   201→  // =============================================================================
   202→  // MUTATIONS
   203→  // =============================================================================
   204→  const TYPE_TO_EFFORT: Record<Task["type"], number> = {
   205→    Quick: 1,
   206→    Standard: 2,
   207→    Chunky: 3,
   208→    Deep: 4,
   209→  }
   210→
   211→  const completeTask = async (id: string) => {
   212→    const taskToComplete = tasks.find((t) => t.id === id)
   213→    const effortEstimate = taskToComplete ? (TYPE_TO_EFFORT[taskToComplete.type] ?? 2) : 2
   214→
   215→    if (shouldUseMockMode()) {
   216→      updateLocalTask(id, { status: "done" as TaskStatus, completedAt: Date.now() })
   217→      trackCompletedTask({ id: Number.parseInt(id, 10), effortEstimate })
   218→    }
   219→
   220→    mutate(
   221→      (current: Task[] | undefined) =>
   222→        current?.map((t) => (t.id === id ? { ...t, status: "done" as TaskStatus, completedAt: Date.now() } : t)),
   223→      false,
   224→    )
   225→
   226→    try {
   227→      const response = await apiFetch<{ hitGoalToday?: boolean; currentStreak?: number }>(`/api/tasks/${id}/complete`, { method: "POST" })
   228→
   229→      console.log("[v0] completeTask: Task completed, triggering milestone check")
   230→      try {
   231→        const milestoneRes = await fetch("/api/notifications/milestone", { method: "POST" })
   232→        const milestoneData = await milestoneRes.json()
   233→        console.log("[v0] completeTask: Milestone check result", milestoneData)
   234→      } catch (notifyErr) {
   235→        console.log("[v0] completeTask: Milestone notification check failed:", notifyErr)
   236→      }
   237→
   238→      globalMutate("/api/metrics/today")
   239→      globalMutate("/api/metrics/clients")
   240→      globalMutate("/api/streaks")
   241→      mutate()
   242→
   243→      return response
   244→    } catch (err) {
   245→      if (!shouldUseMockMode()) throw err
   246→      console.log("[v0] completeTask: API failed in preview, using local state")
   247→      globalMutate("/api/metrics/today")
   248→      globalMutate("/api/metrics/clients")
   249→    }
   250→  }
   251→
   252→  const restoreTask = async (id: string, previousStatus: TaskStatus = "today") => {
   253→    if (shouldUseMockMode()) {
   254→      updateLocalTask(id, { status: previousStatus, completedAt: undefined })
   255→    }
   256→
   257→    mutate(
   258→      (current: Task[] | undefined) =>
   259→        current?.map((t) => (t.id === id ? { ...t, status: previousStatus, completedAt: undefined } : t)),
   260→      false,
   261→    )
   262→
   263→    try {
   264→      await apiFetch(`/api/tasks/${id}`, {
   265→        method: "PATCH",
   266→        body: JSON.stringify({ status: statusToBackend[previousStatus], completedAt: null }),
   267→      })
   268→      mutate()
   269→    } catch (err) {
   270→      if (!shouldUseMockMode()) throw err
   271→      console.log("[v0] restoreTask: API failed in preview, using local state")
   272→    }
   273→  }
   274→
   275→  const updateTaskStatus = async (id: string, newStatus: TaskStatus, insertAtIndex?: number) => {
   276→    if (shouldUseMockMode()) {
   277→      updateLocalTask(id, { status: newStatus })
   278→    }
   279→
   280→    let newSortOrder: number | undefined
   281→    if (insertAtIndex !== undefined) {
   282→      const targetTasks = tasks
   283→        .filter((t) => t.status === newStatus)
   284→        .sort((a, b) => (a.sortOrder ?? 0) - (b.sortOrder ?? 0))
   285→
   286→      if (targetTasks.length === 0) {
   287→        newSortOrder = 0
   288→      } else if (insertAtIndex === 0) {
   289→        newSortOrder = (targetTasks[0]?.sortOrder ?? 0) - 1
   290→      } else if (insertAtIndex >= targetTasks.length) {
   291→        newSortOrder = (targetTasks[targetTasks.length - 1]?.sortOrder ?? 0) + 1
   292→      } else {
   293→        const before = targetTasks[insertAtIndex - 1]?.sortOrder ?? 0
   294→        const after = targetTasks[insertAtIndex]?.sortOrder ?? 0
   295→        newSortOrder = (before + after) / 2
   296→      }
   297→    }
   298→
   299→    mutate((current: Task[] | undefined) => {
   300→      if (!current) return current
   301→      const taskToUpdate = current.find((t) => t.id === id)
   302→      if (!taskToUpdate) return current
   303→
   304→      const withoutTask = current.filter((t) => t.id !== id)
   305→      const updatedTask = { ...taskToUpdate, status: newStatus, sortOrder: newSortOrder }
   306→
   307→      return [...withoutTask, updatedTask]
   308→    }, false)
   309→
   310→    try {
   311→      await apiFetch(`/api/tasks/${id}`, {
   312→        method: "PATCH",
   313→        body: JSON.stringify({
   314→          status: statusToBackend[newStatus],
   315→          sortOrder: newSortOrder,
   316→        }),
   317→      })
   318→    } catch (err) {
   319→      if (!shouldUseMockMode()) throw err
   320→      console.log("[v0] updateTaskStatus: API failed in preview, using local state")
   321→    }
   322→  }
   323→
   324→  const reorderTasks = async (status: TaskStatus, orderedIds: string[]) => {
   325→    mutate((current: Task[] | undefined) => {
   326→      if (!current) return current
   327→      const statusTasks = current.filter((t) => t.status === status)
   328→      const otherTasks = current.filter((t) => t.status !== status)
   329→
   330→      const reordered: Task[] = orderedIds
   331→        .map((id, index) => {
   332→          const task = statusTasks.find((t) => t.id === id)
   333→          if (task) {
   334→            return { ...task, sortOrder: index } as Task
   335→          }
   336→          return null
   337→        })
   338→        .filter((t): t is Task => t !== null)
   339→
   340→      return [...otherTasks, ...reordered]
   341→    }, false)
   342→
   343→    try {
   344→      await apiFetch(`/api/tasks/reorder`, {
   345→        method: "POST",
   346→        body: JSON.stringify({
   347→          status: statusToBackend[status],
   348→          orderedIds: orderedIds.map((id) => Number.parseInt(id, 10)),
   349→        }),
   350→      })
   351→      mutate()
   352→    } catch (err) {
   353→      if (!shouldUseMockMode()) throw err
   354→      console.log("[v0] reorderTasks: API failed in preview, using local state")
   355→    }
   356→  }
   357→
   358→  const createTask = async (taskData: {
   359→    title: string
   360→    clientId?: number
   361→    clientName?: string
   362→    description?: string
   363→    status?: TaskStatus
   364→    effortEstimate?: number
   365→    drainType?: string
   366→    pointsAiGuess?: number
   367→    pointsFinal?: number
   368→  }) => {
   369→    const backendStatus = taskData.status ? statusToBackend[taskData.status] : "backlog"
   370→    const targetStatus = taskData.status || "backlog"
   371→
   372→    const optimisticId = `temp-${Date.now()}`
   373→    const optimisticTask: Task = {
   374→      id: optimisticId,
   375→      client: taskData.clientName || "",
   376→      clientId: taskData.clientId,
   377→      clientColor: undefined,
   378→      title: taskData.title,
   379→      description: taskData.description,
   380→      type: effortToType(taskData.effortEstimate || 2),
   381→      effortEstimate: taskData.effortEstimate || 2,
   382→      status: targetStatus,
   383→      ageLabel: "today",
   384→      sortOrder: -1,
   385→      points: taskData.pointsFinal ?? taskData.pointsAiGuess,
   386→      pointsAiGuess: taskData.pointsAiGuess,
   387→      pointsFinal: taskData.pointsFinal,
   388→    }
   389→
   390→    mutate(
   391→      (current: Task[] | undefined) => {
   392→        return current ? [optimisticTask, ...current] : [optimisticTask]
   393→      },
   394→      false,
   395→    )
   396→
   397→    try {
   398→      const response = await apiFetch<BackendTask>("/api/tasks", {
   399→        method: "POST",
   400→        body: JSON.stringify({
   401→          title: taskData.title,
   402→          clientId: taskData.clientId || null,
   403→          description: taskData.description || null,
   404→          status: backendStatus,
   405→          effortEstimate: taskData.effortEstimate || 2,
   406→          drainType: taskData.drainType || null,
   407→          sortOrder: -1,
   408→          pointsAiGuess: taskData.pointsAiGuess || null,
   409→          pointsFinal: taskData.pointsFinal || null,
   410→        }),
   411→      })
   412→
   413→      mutate(
   414→        (current: Task[] | undefined) => {
   415→          if (!current) return current
   416→          return current.map((t) =>
   417→            t.id === optimisticId
   418→              ? {
   419→                  ...t,
   420→                  id: response.id.toString(),
   421→                  client: response.clientName || taskData.clientName || "",
   422→                  clientColor: response.client?.color ?? undefined,
   423→                }
   424→              : t,
   425→          )
   426→        },
   427→        false,
   428→      )
   429→
   430→      return response
   431→    } catch (err) {
   432→      if (shouldUseMockMode()) {
   433→        const localTaskId = `local-${Date.now()}`
   434→        addLocalTask({ ...optimisticTask, id: localTaskId })
   435→
   436→        mutate((current: Task[] | undefined) => {
   437→          if (!current) return current
   438→          return current.map((t) => (t.id === optimisticId ? { ...t, id: localTaskId } : t))
   439→        }, false)
   440→
   441→        return { id: Number(localTaskId) } as BackendTask
   442→      }
   443→
   444→      mutate((current: Task[] | undefined) => {
   445→        if (!current) return current
   446→        return current.filter((t) => t.id !== optimisticId)
   447→      }, false)
   448→      throw err
   449→    }
   450→  }
   451→
   452→  const updateTask = async (
   453→    id: string,
   454→    taskData: {
   455→      title?: string
   456→      clientId?: number
   457→      description?: string
   458→      status?: TaskStatus
   459→      effortEstimate?: number
   460→      drainType?: string
   461→    },
   462→  ) => {
   463→    const backendStatus = taskData.status ? statusToBackend[taskData.status] : undefined
   464→
   465→    mutate((current: Task[] | undefined) => {
   466→      if (!current) return current
   467→      return current.map((t) => {
   468→        if (t.id !== id) return t
   469→        return {
   470→          ...t,
   471→          title: taskData.title ?? t.title,
   472→          clientId: taskData.clientId ?? t.clientId,
   473→          description: taskData.description ?? t.description,
   474→          status: taskData.status ?? t.status,
   475→          type: taskData.effortEstimate ? effortToType(taskData.effortEstimate) : t.type,
   476→          effortEstimate: taskData.effortEstimate ?? t.effortEstimate,
   477→        }
   478→      })
   479→    }, false)
   480→
   481→    try {
   482→      await apiFetch(`/api/tasks/${id}`, {
   483→        method: "PATCH",
   484→        body: JSON.stringify({
   485→          title: taskData.title,
   486→          clientId: taskData.clientId,
   487→          description: taskData.description,
   488→          status: backendStatus,
   489→          effortEstimate: taskData.effortEstimate,
   490→          drainType: taskData.drainType,
   491→        }),
   492→      })
   493→      mutate()
   494→    } catch (err) {
   495→      if (!shouldUseMockMode()) throw err
   496→      console.log("[v0] updateTask: API failed in preview, using local state")
   497→    }
   498→  }
   499→
   500→  const updateSubtasks = async (id: string, subtasks: Subtask[]) => {
   501→    mutate((current: Task[] | undefined) => {
   502→      if (!current) return current
   503→      return current.map((t) => (t.id === id ? { ...t, subtasks } : t))
   504→    }, false)
   505→
   506→    try {
   507→      await apiFetch(`/api/tasks/${id}`, {
   508→        method: "PATCH",
   509→        body: JSON.stringify({ subtasks }),
   510→      })
   511→      mutate()
   512→    } catch (err) {
   513→      if (!shouldUseMockMode()) throw err
   514→      console.log("[v0] updateSubtasks: API failed in preview, using local state")
   515→    }
   516→  }
   517→
   518→  const setSubtasksFromTitles = async (id: string, titles: string[]) => {
   519→    const subtasks: Subtask[] = titles.map((title) => ({
   520→      id: `subtask-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
   521→      title,
   522→      completed: false,
   523→    }))
   524→    await updateSubtasks(id, subtasks)
   525→  }
   526→
   527→  const promoteTask = async (id: string) => {
   528→    return updateTaskStatus(id, "upnext")
   529→  }
   530→
   531→  const deleteTask = async (id: string) => {
   532→    mutate((current: Task[] | undefined) => {
   533→      if (!current) return current
   534→      return current.filter((t) => t.id !== id)
   535→    }, false)
   536→
   537→    try {
   538→      await apiFetch(`/api/tasks/${id}`, { method: "DELETE" })
   539→      globalMutate("/api/backlog/grouped")
   540→      globalMutate("/api/backlog/recommendations")
   541→    } catch (err) {
   542→      if (!shouldUseMockMode()) {
   543→        mutate()
   544→        throw err
   545→      }
   546→      console.log("[v0] deleteTask: API failed in preview, using local state")
   547→      removeLocalTask(id)
   548→    }
   549→  }
   550→
   551→  return {
   552→    tasks,
   553→    // Legacy aliases
   554→    moves: tasks,
   555→    loading: isLoading,
   556→    isLoading,
   557→    error,
   558→    todayTasks: byStatus("today"),
   559→    upNextTasks: byStatus("upnext"),
   560→    backlogTasks: byStatus("backlog"),
   561→    doneTasks: byStatus("done"),
   562→    // Legacy aliases
   563→    todayMoves: byStatus("today"),
   564→    upNextMoves: byStatus("upnext"),
   565→    backlogMoves: byStatus("backlog"),
   566→    doneMoves: byStatus("done"),
   567→    completeTask,
   568→    restoreTask,
   569→    updateTaskStatus,
   570→    reorderTasks,
   571→    createTask,
   572→    updateTask,
   573→    updateSubtasks,
   574→    setSubtasksFromTitles,
   575→    promoteTask,
   576→    deleteTask,
   577→    // Legacy aliases
   578→    completeMove: completeTask,
   579→    restoreMove: restoreTask,
   580→    updateMoveStatus: updateTaskStatus,
   581→    reorderMoves: reorderTasks,
   582→    createMove: createTask,
   583→    updateMove: updateTask,
   584→    promoteMove: promoteTask,
   585→    deleteMove: deleteTask,
   586→    refresh: () => mutate(),
   587→  }
   588→}
   589→
   590→// Legacy alias
   591→export const useMoves = useTasks
   592→
   593→// =============================================================================
   594→// CLIENTS HOOK
   595→// =============================================================================
   596→interface BackendClient {
   597→  id: number
   598→  name: string
   599→  type: string
   600→  color: string | null
   601→  isActive: number
   602→  createdAt: string
   603→}
   604→
   605→export interface Client {
   606→  id: number
   607→  name: string
   608→  color?: string
   609→  isActive: boolean
   610→}
   611→
   612→export function useClients() {
   613→  const { data, error, isLoading } = useSWR<Client[]>(
   614→    "clients",
   615→    async () => {
   616→      let backendClients: BackendClient[] = []
   617→      try {
   618→        backendClients = await apiFetch<BackendClient[]>("/api/clients")
   619→      } catch (err) {
   620→        console.log("[v0] useClients: API error, will use mock data if in preview", err)
   621→      }
   622→
   623→      const clientsToUse = mergeWithMockData(backendClients, MOCK_CLIENTS as any)
   624→
   625→      const mapped = clientsToUse
   626→        .filter((c) => c.isActive === 1)
   627→        .map((c) => ({
   628→          id: c.id,
   629→          name: c.name,
   630→          color: c.color ?? undefined,
   631→          isActive: c.isActive === 1,
   632→        }))
   633→
   634→      return mapped
   635→    },
   636→    {
   637→      refreshInterval: 30000,
   638→      revalidateOnFocus: true,
   639→      revalidateOnMount: true,
   640→    },
   641→  )
   642→
   643→  return {
   644→    clients: data ?? [],
   645→    isLoading,
   646→    error,
   647→  }
   648→}
   649→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

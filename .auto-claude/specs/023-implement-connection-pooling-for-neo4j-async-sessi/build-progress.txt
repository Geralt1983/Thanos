=============================================================================
NEO4J SESSION POOLING - BUILD PROGRESS
=============================================================================

PHASE 1: RESEARCH & DESIGN
=============================================================================

Subtask 1.1: Analyze current session usage patterns
Status: COMPLETED
Date: 2026-01-11

=============================================================================
CURRENT SESSION CREATION PATTERNS ANALYSIS
=============================================================================

OVERVIEW
--------
The Neo4j adapter currently creates a new session for EVERY operation using
the pattern: `async with self._driver.session() as session:`

Each method creates exactly one session that is automatically closed when
the context manager exits. While the Neo4j driver has connection pooling
at the driver level, session creation still has overhead that could be
reduced through session reuse.

DETAILED METHOD ANALYSIS
-------------------------

1. COMMITMENT OPERATIONS (3 methods, 3 sessions)
   - _create_commitment (line 360-398)
     * Creates 1 session
     * Executes 1 query: CREATE commitment node
     * Pattern: async with self._driver.session()

   - _complete_commitment (line 400-429)
     * Creates 1 session
     * Executes 1 query: MATCH + SET status to completed
     * Pattern: async with self._driver.session()

   - _get_commitments (line 431-463)
     * Creates 1 session
     * Executes 1 query: MATCH with filters + RETURN
     * Pattern: async with self._driver.session()

2. DECISION OPERATIONS (2 methods, 2 sessions)
   - _record_decision (line 469-505)
     * Creates 1 session
     * Executes 1 query: CREATE decision node
     * Pattern: async with self._driver.session()

   - _get_decisions (line 507-535)
     * Creates 1 session
     * Executes 1 query: MATCH with filters + RETURN
     * Pattern: async with self._driver.session()

3. PATTERN OPERATIONS (2 methods, 2 sessions)
   - _record_pattern (line 541-613) ⭐ GOOD PATTERN
     * Creates 1 session but REUSES it for multiple queries
     * Executes 2-3 queries within same session:
       1. check_query: MATCH existing pattern
       2a. update_query: SET if exists (OR)
       2b. create_query: CREATE if new
     * Pattern: async with self._driver.session() wrapping multiple await session.run()
     * THIS IS THE PATTERN WE WANT TO REPLICATE!

   - _get_patterns (line 615-643)
     * Creates 1 session
     * Executes 1 query: MATCH with filters + RETURN
     * Pattern: async with self._driver.session()

4. SESSION OPERATIONS (2 methods, 2 sessions)
   - _start_session (line 649-674)
     * Creates 1 session
     * Executes 1 query: CREATE session node
     * Pattern: async with self._driver.session()

   - _end_session (line 676-703)
     * Creates 1 session
     * Executes 1 query: MATCH + SET end data
     * Pattern: async with self._driver.session()

5. RELATIONSHIP OPERATIONS (3 methods, 3 sessions)
   - _link_nodes (line 709-742)
     * Creates 1 session
     * Executes 1 query: MATCH + MATCH + CREATE relationship
     * Pattern: async with self._driver.session()

   - _find_related (line 744-764)
     * Creates 1 session
     * Executes 1 query: MATCH with variable depth traversal
     * Pattern: async with self._driver.session()

   - _query_graph (line 766-783)
     * Creates 1 session
     * Executes 1 query: User-provided Cypher (read-only)
     * Pattern: async with self._driver.session()

6. ENTITY OPERATIONS (2 methods, 2 sessions)
   - _create_entity (line 789-825)
     * Creates 1 session
     * Executes 1 query: MERGE entity (create or update)
     * Pattern: async with self._driver.session()

   - _get_entity_context (line 827-852)
     * Creates 1 session
     * Executes 1 query: Complex MATCH with OPTIONAL MATCHes
     * Pattern: async with self._driver.session()

7. UTILITY OPERATIONS (1 method, 1 session)
   - health_check (line 862-878)
     * Creates 1 session
     * Executes 1 query: RETURN 1 (connectivity test)
     * Pattern: async with self._driver.session()

TOTAL: 15 methods, 15 sessions created (one per operation)

=============================================================================
SESSION REUSE OPPORTUNITIES
=============================================================================

HIGH IMPACT - Multi-operation workflows:
------------------------------------------
1. Memory Storage Workflow (mentioned in spec)
   * As described in spec: memory_integration.py's store_memory creates:
     - Vector storage operation
     - Decision recording
     - Entity creation
     - Relationship linking
   * Current: 4 separate sessions
   * Opportunity: 1 shared session = 75% reduction

2. Entity Context Building
   * _create_entity + multiple _link_nodes calls
   * Common pattern when adding related entities
   * Current: N+1 sessions (1 for entity + N for relationships)
   * Opportunity: 1 shared session

3. Commitment Tracking Workflow
   * _create_commitment + _link_nodes (to session/entity)
   * Current: 2 sessions
   * Opportunity: 1 shared session = 50% reduction

4. Session Recording Workflow
   * _start_session + multiple operations + _end_session
   * Current: 2+ sessions
   * Opportunity: 1 shared session

MEDIUM IMPACT - Batch operations:
-----------------------------------
5. Bulk Entity Creation
   * Multiple _create_entity calls
   * Current: N sessions
   * Opportunity: 1 shared session

6. Relationship Creation Batches
   * Multiple _link_nodes calls
   * Current: N sessions
   * Opportunity: 1 shared session

LOW IMPACT - Already optimal:
-------------------------------
7. _record_pattern (already reuses session for check + update/create)
   * No change needed - this is the pattern to follow!

8. Single query operations
   * _get_commitments, _get_decisions, _get_patterns
   * These are already optimal when called individually
   * Benefit only comes if called as part of batch

=============================================================================
PATTERN ANALYSIS
=============================================================================

CURRENT PATTERN (used by 14/15 methods):
-----------------------------------------
```python
async def _operation(self, args: Dict[str, Any]) -> ToolResult:
    query = "..."
    params = {...}

    async with self._driver.session() as session:
        result = await session.run(query, params)
        # process result

    return ToolResult.ok(...)
```

EXISTING GOOD PATTERN (_record_pattern shows the way):
-------------------------------------------------------
```python
async def _record_pattern(self, args: Dict[str, Any]) -> ToolResult:
    # Prepare queries
    check_query = "..."
    update_query = "..."
    create_query = "..."

    async with self._driver.session() as session:
        # Query 1: Check
        result = await session.run(check_query, {...})
        existing = await result.single()

        if existing:
            # Query 2a: Update
            await session.run(update_query, {...})
        else:
            # Query 2b: Create
            await session.run(create_query, {...})

    return ToolResult.ok(...)
```

This demonstrates session reuse within a single method - we need to extend
this pattern to work ACROSS methods.

=============================================================================
KEY INSIGHTS FOR DESIGN
=============================================================================

1. SESSION LIFECYCLE
   * Sessions are lightweight but not free
   * Neo4j driver already pools connections (not sessions)
   * Session reuse reduces overhead in multi-operation workflows

2. TRANSACTION BOUNDARIES
   * Current: Each operation is implicitly a separate transaction
   * Consideration: When batching, decide transaction scope
   * Some operations need atomicity, others don't

3. BACKWARD COMPATIBILITY CRITICAL
   * All 15 methods are public API (via call_tool routing)
   * Must maintain current behavior when called individually
   * Session parameter must be OPTIONAL

4. ERROR HANDLING
   * Sessions must be cleaned up even on errors
   * Context managers handle this automatically
   * Need to preserve this behavior in pooled approach

5. ASYNC CONTEXT
   * Python's contextvars module can track session per async context
   * Allows implicit session reuse without passing parameters everywhere
   * Alternative: Explicit session parameter (simpler but more invasive)

=============================================================================
NEXT STEPS
=============================================================================

Subtask 1.2: Research Neo4j async session best practices
  - Review Neo4j Python driver docs
  - Understand session vs transaction lifecycle
  - Identify recommended patterns for async session management
  - Document transaction isolation considerations

Subtask 1.3: Design session pooling strategy
  - Choose between:
    a) Context-based session reuse (contextvars)
    b) Explicit session parameter pattern
    c) Transaction batching with session manager
  - Define backward compatibility approach
  - Design error handling strategy
  - Document chosen approach with rationale

=============================================================================

Subtask 1.2: Research Neo4j async session best practices
Status: COMPLETED
Date: 2026-01-11

=============================================================================
NEO4J PYTHON DRIVER - ASYNC SESSION BEST PRACTICES RESEARCH
=============================================================================

DOCUMENTATION SOURCES
---------------------
- Neo4j Python Driver Manual - Concurrency Guide
- Neo4j Python Driver Manual - Performance Recommendations
- Neo4j Python Driver Manual - Transaction Handling
- Neo4j Python Driver 6.0 Async API Documentation

=============================================================================
CONNECTION POOLING ARCHITECTURE
=============================================================================

DRIVER-LEVEL CONNECTION POOLING (BUILT-IN)
-------------------------------------------
✅ The Neo4j driver ALREADY handles connection pooling automatically:
   - Driver objects open connections and pool them as needed
   - Connections are drawn from the AsyncDriver connection pool as required
   - When a session is CLOSED, connections return to the pool for reuse
   - Connection pooling is at the DRIVER level, not the SESSION level

KEY INSIGHT:
------------
"Driver objects only open connections and pool them as needed. Connections
are drawn from the neo4j.AsyncDriver connection pool as required. When a
session is closed, it is returned to the connection pool to be later reused."

IMPLICATION FOR OUR TASK:
-------------------------
We're NOT pooling connections (driver does this). We're optimizing SESSION
reuse to reduce the overhead of creating/closing sessions for multiple
operations within the same logical workflow.

=============================================================================
ASYNC SESSION MANAGEMENT PATTERNS
=============================================================================

RECOMMENDED PATTERN - Context Manager:
--------------------------------------
```python
async with driver.session(database="<database-name>") as session:
    # Session operations here
    records = await session.execute_read(transaction_function)
```

✅ Benefits:
   - Automatic resource cleanup
   - Exception-safe session closure
   - Ensures connection returns to pool

SESSION LIFECYCLE:
------------------
1. Session creation is LIGHTWEIGHT (per docs)
2. Sessions are NOT thread-safe (not concurrent-safe for async)
3. Sessions should NOT be shared across multiple async tasks
4. A session can chain multiple transactions
5. Only ONE transaction can be active per session at a time

CRITICAL CONSTRAINT:
--------------------
"AsyncSession objects are not concurrency-safe, meaning they should not be
used concurrently from multiple tasks."

This means we CANNOT share a session across concurrent operations, but we
CAN reuse a session for SEQUENTIAL operations within the same async context.

=============================================================================
TRANSACTION HANDLING RECOMMENDATIONS
=============================================================================

TRANSACTION TYPES (in order of sophistication):
------------------------------------------------

1. AUTO-COMMIT TRANSACTIONS (Highest throughput, no retry)
   Pattern: session.run(query, params)
   Use case: Simple queries, maximum speed
   Limitations:
   - Only one statement per transaction
   - NOT automatically retried on failure
   - Still isolated from other concurrent queries

   ⚠️  "Auto-commit transactions support only one statement per transaction
       and are not automatically retried on failure"

2. MANAGED TRANSACTIONS (Recommended, automatic retry)
   Pattern: session.execute_read(callback) / session.execute_write(callback)
   Use case: Production code requiring reliability
   Benefits:
   - Automatic retry on transient server failures
   - Driver manages transaction lifecycle
   - Callback pattern ensures proper resource handling

   ✅ "The driver automatically re-executes the callback in case of server
      failure"

3. EXPLICIT TRANSACTIONS (Full control, manual retry)
   Pattern: tx = session.begin_transaction() / tx.commit() / tx.rollback()
   Use case: Complex workflows, manual control needed
   Benefits:
   - Full manual control over commit/rollback
   - Useful for distributing queries across multiple functions
   - Can integrate with external systems

   Requirements:
   - Must manually handle retry logic
   - Must check Neo4jError.is_retryable() for retry decisions

TRANSACTION FUNCTION REQUIREMENTS:
----------------------------------
Transaction functions MUST be IDEMPOTENT:
- Must produce identical results if executed multiple times
- Process results within the function (never return raw Result objects)
- Cast results to lists or use .single(), .fetch(n), .value()
- Don't rely on global state modifications
- Can include client-side logic between queries

EXAMPLE PATTERN:
```python
async def transaction_callback(tx):
    result1 = await tx.run(query1, params1)
    data1 = await result1.single()

    # Client-side logic
    processed = process(data1)

    result2 = await tx.run(query2, processed)
    return await result2.values()

# Use it
records = await session.execute_write(transaction_callback)
```

=============================================================================
SESSION REUSE PATTERNS
=============================================================================

PATTERN 1: Single Session, Multiple Transactions
-------------------------------------------------
✅ RECOMMENDED for sequential operations:

```python
async with driver.session(database="neo4j") as session:
    # Transaction 1
    await session.execute_write(create_entity_tx)

    # Transaction 2
    await session.execute_write(link_nodes_tx)

    # Transaction 3
    await session.execute_read(get_context_tx)
```

Benefits:
- Session created once
- Multiple transactions in sequence
- Each transaction retried independently
- Automatic cleanup on exit

PATTERN 2: Single Transaction, Multiple Queries
------------------------------------------------
✅ RECOMMENDED for atomic batch operations:

```python
async def batch_operation_tx(tx, data):
    # Query 1
    result1 = await tx.run(query1, data[0])

    # Query 2
    result2 = await tx.run(query2, data[1])

    # Query 3
    result3 = await tx.run(query3, data[2])

    return await result3.values()

async with driver.session() as session:
    result = await session.execute_write(batch_operation_tx, batch_data)
```

Benefits:
- All queries in single transaction (atomic)
- Automatic retry of entire transaction
- Best for related operations that should succeed/fail together

PATTERN 3: Auto-Commit for Maximum Throughput
----------------------------------------------
✅ Use when retry not needed:

```python
async with driver.session() as session:
    await session.run(query1, params1)
    await session.run(query2, params2)
    await session.run(query3, params3)
```

Benefits:
- Highest throughput
- Still uses single session
- Each query is separate transaction
- No automatic retry

⚠️  Trade-off: No automatic retry, queries not atomic

=============================================================================
CAUSAL CONSISTENCY
=============================================================================

BOOKMARKING FOR SEQUENTIAL CONSISTENCY:
---------------------------------------
✅ Sessions automatically chain bookmarks from each query

"If doing a sequence of operations where later operations need to be
guaranteed to read writes from earlier operations, simply reuse the same
session object - sessions automatically chain bookmarks from each query."

IMPLICATION:
------------
When we reuse a session for multiple operations, we get causal consistency
for free! Later operations will see the results of earlier ones.

=============================================================================
PERFORMANCE RECOMMENDATIONS
=============================================================================

1. DATABASE SPECIFICATION
   ⚠️  ALWAYS specify database parameter on sessions:

   "If no database is provided, the driver has to send an extra request to
   the server to figure out what the default database is."

   Impact: Adds network round-trip per session creation
   Fix: async with driver.session(database="neo4j") as session:

2. TRANSACTION BATCHING
   ✅ "Group queries into one transaction (higher throughput)"

   Instead of:
   ```python
   async with driver.session() as s1:
       await s1.run(q1)
   async with driver.session() as s2:
       await s2.run(q2)
   ```

   Do:
   ```python
   async with driver.session() as session:
       await session.run(q1)
       await session.run(q2)
   ```

3. TRANSACTION OVERHEAD AWARENESS
   "Creating a safe execution context around a query yields an overhead that
   is small, but that adds up as the number of transactions increases."

   Strategy: Batch related operations to minimize transaction count

4. READ/WRITE ROUTING
   - Use default_access_mode=READ_ACCESS for read-only sessions
   - Optimizes routing in clustered environments
   - Allows better load distribution

5. FETCH SIZE CONFIGURATION
   - Large values for queries returning many records
   - Smaller values for interactive applications
   - Affects memory usage and network efficiency

=============================================================================
ERROR HANDLING & CLEANUP
=============================================================================

AUTOMATIC ROLLBACK:
-------------------
- Returning from transaction function = COMMIT
- Raising exception = ROLLBACK
- Context manager ensures cleanup even on errors

RETRY LOGIC:
------------
For managed transactions (execute_read/write):
✅ Automatic retry on transient errors

For explicit transactions:
⚠️  Manual retry required
   Check: Neo4jError.is_retryable()

TIMEOUT CONFIGURATION:
----------------------
Use @unit_of_work() decorator for transaction timeouts:
- Minimum: 0.001 seconds
- Can attach metadata for monitoring

RESOURCE CLEANUP:
-----------------
✅ ALWAYS use async with context managers:
   - Ensures session closure
   - Returns connection to pool
   - Exception-safe cleanup

⚠️  "The driver object is concurrency-safe, but close is not - ensure you're
    not using the driver or any spawned resources (sessions or transactions)
    while calling close"

=============================================================================
KEY INSIGHTS FOR OUR DESIGN
=============================================================================

1. SESSION REUSE IS VALUABLE
   ✅ Reduces overhead of session creation/cleanup
   ✅ Provides causal consistency via automatic bookmarking
   ✅ Allows batching operations to reduce transaction count

2. SESSION REUSE CONSTRAINTS
   ⚠️  Sessions are NOT concurrency-safe (can't share across async tasks)
   ✅ Sessions CAN be reused for sequential operations
   ✅ Only one transaction active per session at a time

3. TRANSACTION STRATEGY CHOICES
   Option A: Multiple managed transactions in one session
   - Each transaction retried independently
   - Not atomic across transactions
   - Good for: Independent operations in sequence

   Option B: Single transaction with multiple queries
   - All queries atomic
   - Entire transaction retried as unit
   - Good for: Related operations that must succeed/fail together

   Option C: Auto-commit queries in one session
   - Highest throughput
   - No retry
   - Good for: Maximum performance, retry handled at higher level

4. BACKWARD COMPATIBILITY APPROACH
   ✅ Make session parameter optional
   ✅ Default behavior: create session per operation (current)
   ✅ New behavior: accept session parameter for reuse
   ✅ Maintains all existing call patterns

5. ERROR HANDLING REQUIREMENTS
   ✅ Use async context managers for automatic cleanup
   ✅ Preserve exception propagation
   ✅ Ensure sessions always returned to pool
   ✅ Don't break existing error handling patterns

6. PYTHON VERSION CONSIDERATION
   ⚠️  "Known issue with Python 3.8 and async driver where it gradually
       slows down"
   Recommendation: Document minimum Python 3.9+ for optimal performance

=============================================================================
RECOMMENDED DESIGN DIRECTION
=============================================================================

Based on research, recommend HYBRID APPROACH:

1. ADD OPTIONAL SESSION PARAMETER
   - All adapter methods accept optional `session: AsyncSession = None`
   - If None: create session (current behavior)
   - If provided: reuse session (new optimization)

2. CREATE SESSION CONTEXT MANAGER
   - Provide helper for common batch patterns
   - Example: Neo4jAdapter.batch_context()
   - Yields session for multiple operations
   - Handles cleanup automatically

3. ADD BATCH OPERATION METHODS
   - High-level methods for common workflows
   - Example: store_memory_batch()
   - Uses session context internally
   - Simplifies caller code

4. TRANSACTION STRATEGY
   - Use managed transactions (execute_read/write) for reliability
   - Support both:
     a) Multiple transactions per session (independent retry)
     b) Single transaction batching (atomic operations)
   - Let caller choose based on atomicity needs

5. ALWAYS SPECIFY DATABASE
   - Add database parameter to session creation
   - Eliminates extra network round-trip
   - Improves performance baseline

NEXT STEP:
----------
Subtask 1.3: Design detailed session pooling strategy with:
- Class/method signatures
- Interaction patterns
- Error handling flows
- Migration path for existing code
- Performance expectations

=============================================================================

Subtask 1.3: Design session pooling strategy
Status: COMPLETED
Date: 2026-01-11

=============================================================================
SESSION POOLING STRATEGY - FINAL DESIGN DECISION
=============================================================================

CHOSEN APPROACH: Async Context Manager Pattern with Optional Session Parameter
--------------------------------------------------------------------------------

After evaluating three primary approaches, the chosen strategy is a HYBRID
APPROACH that combines the best aspects of all three options:

APPROACH EVALUATION:
--------------------

Option 1: Context-based session reuse (contextvars)
  ❌ Rejected - Reasons:
     - Implicit behavior makes debugging harder
     - Hidden state can lead to unexpected session sharing
     - More complex to reason about in async contexts
     - Risk of session leakage across unrelated operations
  ✅ Benefit (not chosen):
     - No API changes needed
     - Transparent to callers

Option 2: Transaction batching only
  ❌ Rejected as sole approach - Reasons:
     - Too restrictive - forces all operations into transactions
     - Not all workflows need atomic guarantees
     - Removes flexibility for independent retry of operations
  ✅ Benefits (incorporated into hybrid):
     - Atomic guarantees when needed
     - Maximum performance for related operations

Option 3: Async context manager pattern
  ✅ SELECTED as foundation - Reasons:
     - Explicit and clear - no hidden state
     - Follows Neo4j driver recommendations
     - Automatic resource cleanup via __aexit__
     - Exception-safe by design
     - Pythonic and familiar pattern
     - Flexible for various usage patterns
  ✅ Additional benefits:
     - Enables both session reuse AND transaction batching
     - Backward compatible when combined with optional parameters
     - Easy to test and verify

FINAL DESIGN: Hybrid Approach
------------------------------
Combines async context manager pattern with optional session parameters and
transaction batching support.

=============================================================================
DETAILED DESIGN SPECIFICATION
=============================================================================

COMPONENT 1: Optional Session Parameter on All Adapter Methods
---------------------------------------------------------------

APPROACH:
All Neo4j adapter methods will be refactored to accept an optional session
parameter while maintaining full backward compatibility.

SIGNATURE PATTERN:
```python
async def _operation_name(
    self,
    args: Dict[str, Any],
    session: Optional[Any] = None  # AsyncSession from neo4j
) -> ToolResult:
```

BEHAVIOR:
- If session=None (default): Create session per operation (CURRENT BEHAVIOR)
- If session provided: Reuse provided session (NEW OPTIMIZATION)

BACKWARD COMPATIBILITY:
✅ All existing calls work unchanged (session defaults to None)
✅ No breaking changes to public API
✅ Gradual migration path for callers

AFFECTED METHODS (15 total):
1. _create_commitment
2. _complete_commitment
3. _get_commitments
4. _record_decision
5. _get_decisions
6. _record_pattern
7. _get_patterns
8. _start_session
9. _end_session
10. _link_nodes
11. _find_related
12. _query_graph
13. _create_entity
14. _get_entity_context
15. health_check

COMPONENT 2: Session Context Manager
-------------------------------------

Create a dedicated async context manager class for managing session lifecycle
and supporting nested operations.

CLASS DESIGN:
```python
class Neo4jSessionContext:
    """
    Async context manager for Neo4j session lifecycle management.

    Provides:
    - Automatic session creation/cleanup
    - Support for session reuse across operations
    - Exception-safe resource handling
    - Optional transaction batching
    """

    def __init__(
        self,
        adapter: 'Neo4jAdapter',
        database: str = "neo4j",
        batch_transaction: bool = False
    ):
        """
        Initialize session context.

        Args:
            adapter: Neo4jAdapter instance
            database: Neo4j database name (avoids extra round-trip)
            batch_transaction: If True, wrap all operations in single transaction
        """
        self._adapter = adapter
        self._database = database
        self._batch_transaction = batch_transaction
        self._session = None
        self._transaction = None

    async def __aenter__(self):
        """Create session and optionally begin transaction."""
        self._session = self._adapter._driver.session(database=self._database)

        if self._batch_transaction:
            # Start explicit transaction for atomic batch
            self._transaction = await self._session.begin_transaction()
            return self._transaction

        return self._session

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Cleanup session and handle transaction commit/rollback."""
        try:
            if self._transaction:
                if exc_type is None:
                    # No exception - commit transaction
                    await self._transaction.commit()
                else:
                    # Exception occurred - rollback transaction
                    await self._transaction.rollback()
        finally:
            # Always close session
            if self._session:
                await self._session.close()

        # Don't suppress exceptions
        return False
```

USAGE PATTERNS:

Pattern A: Session reuse for multiple independent operations
```python
async with adapter.session_context() as session:
    # Each operation is separate transaction
    await adapter._create_entity(entity_data, session=session)
    await adapter._link_nodes(link_data, session=session)
    await adapter._get_entity_context(query_data, session=session)

# Session automatically closed, even on error
```

Pattern B: Atomic batch with transaction guarantee
```python
async with adapter.session_context(batch_transaction=True) as tx:
    # All operations in single atomic transaction
    await adapter._create_entity(entity_data, session=tx)
    await adapter._link_nodes(link_data, session=tx)
    # If any operation fails, entire batch rolls back

# Transaction committed if successful, rolled back on error
```

Pattern C: Current behavior (backward compatible)
```python
# No session provided - creates session per operation as before
await adapter._create_entity(entity_data)
await adapter._link_nodes(link_data)
```

COMPONENT 3: High-Level Batch Operation Methods
------------------------------------------------

Create convenience methods for common multi-operation workflows that use
session context internally.

EXAMPLE BATCH METHODS:

```python
async def store_memory_batch(
    self,
    vector_data: Dict[str, Any],
    decision_data: Dict[str, Any],
    entity_data: Dict[str, Any],
    link_data: List[Dict[str, Any]]
) -> ToolResult:
    """
    Store a complete memory with all related operations in one session.

    This is the high-impact optimization mentioned in the spec:
    - Vector storage
    - Decision recording
    - Entity creation
    - Relationship linking

    Reduces 4 sessions to 1 (75% reduction).
    """
    async with self.session_context() as session:
        # Operation 1: Store vector (assume vector adapter called first)

        # Operation 2: Record decision
        decision_result = await self._record_decision(
            decision_data,
            session=session
        )

        # Operation 3: Create entity
        entity_result = await self._create_entity(
            entity_data,
            session=session
        )

        # Operation 4+: Link relationships
        for link in link_data:
            await self._link_nodes(link, session=session)

        return ToolResult.ok({
            "decision": decision_result.result,
            "entity": entity_result.result,
            "links_created": len(link_data)
        })

async def create_commitment_with_context(
    self,
    commitment_data: Dict[str, Any],
    session_id: Optional[str] = None,
    entity_ids: Optional[List[str]] = None
) -> ToolResult:
    """
    Create commitment and link it to session/entities in one session.

    Reduces 2-N sessions to 1.
    """
    async with self.session_context() as session:
        # Create commitment
        commitment_result = await self._create_commitment(
            commitment_data,
            session=session
        )
        commitment_id = commitment_result.result["id"]

        # Link to session if provided
        if session_id:
            await self._link_nodes({
                "from_type": "Commitment",
                "from_id": commitment_id,
                "to_type": "Session",
                "to_id": session_id,
                "relationship_type": "MADE_IN"
            }, session=session)

        # Link to entities if provided
        if entity_ids:
            for entity_id in entity_ids:
                await self._link_nodes({
                    "from_type": "Commitment",
                    "from_id": commitment_id,
                    "to_type": "Entity",
                    "to_id": entity_id,
                    "relationship_type": "INVOLVES"
                }, session=session)

        return commitment_result
```

COMPONENT 4: Database Parameter Optimization
---------------------------------------------

CHANGE: Always specify database parameter in session creation

CURRENT PATTERN:
```python
async with self._driver.session() as session:
```

NEW PATTERN:
```python
async with self._driver.session(database="neo4j") as session:
```

RATIONALE:
Per Neo4j docs: "If no database is provided, the driver has to send an extra
request to the server to figure out what the default database is."

IMPACT: Eliminates one network round-trip per session creation

IMPLEMENTATION:
- Add database parameter to Neo4jAdapter.__init__ (default: "neo4j")
- Use database parameter in all session creation
- Make configurable via environment variable

=============================================================================
TRANSACTION STRATEGY
=============================================================================

The design supports THREE transaction patterns based on use case:

PATTERN 1: Multiple Managed Transactions (Default for session reuse)
---------------------------------------------------------------------
Use Case: Independent operations that don't need atomicity
Benefits:
- Each operation retried independently on failure
- Partial success possible (some ops succeed, others fail)
- Good for: Bulk operations where independence is acceptable

Implementation:
```python
async with adapter.session_context() as session:
    # Transaction 1
    await session.execute_write(operation_1_callback, data1)
    # Transaction 2
    await session.execute_write(operation_2_callback, data2)
```

PATTERN 2: Single Transaction Batch (Atomic operations)
--------------------------------------------------------
Use Case: Related operations that must all succeed or all fail
Benefits:
- Atomic guarantee - all or nothing
- Entire batch retried as unit on transient failure
- Good for: Data consistency critical operations

Implementation:
```python
async with adapter.session_context(batch_transaction=True) as tx:
    await tx.run(query1, params1)
    await tx.run(query2, params2)
    # All queries commit together or rollback together
```

PATTERN 3: Auto-Commit (Maximum throughput)
--------------------------------------------
Use Case: High-performance scenarios where retry handled elsewhere
Benefits:
- Highest throughput
- Lowest latency
- Good for: Monitoring, logging, non-critical operations

Implementation:
```python
async with adapter.session_context() as session:
    await session.run(query1, params1)  # Auto-commit
    await session.run(query2, params2)  # Auto-commit
```

RECOMMENDATION PER OPERATION TYPE:
----------------------------------
- Read operations: Pattern 3 (auto-commit) or Pattern 1 (managed)
- Write operations: Pattern 1 (managed) for reliability
- Atomic workflows: Pattern 2 (single transaction)
- Bulk operations: Pattern 1 (independent retry)

=============================================================================
ERROR HANDLING STRATEGY
=============================================================================

PRINCIPLE: Preserve existing error handling while ensuring cleanup

CONTEXT MANAGER ERROR HANDLING:
```python
async def __aexit__(self, exc_type, exc_val, exc_tb):
    try:
        if self._transaction:
            if exc_type is None:
                await self._transaction.commit()
            else:
                await self._transaction.rollback()
    finally:
        if self._session:
            await self._session.close()

    # Return False to propagate exception
    return False
```

GUARANTEES:
✅ Session always closed, even on exception
✅ Transaction rolled back on error
✅ Exceptions propagate to caller
✅ No session leaks
✅ Connection returned to driver pool

ADAPTER METHOD ERROR HANDLING:
```python
async def _operation(self, args: Dict[str, Any], session=None) -> ToolResult:
    should_close = False
    if session is None:
        session = self._driver.session(database=self._database)
        should_close = True

    try:
        # Operation logic
        result = await session.run(query, params)
        return ToolResult.ok(data)

    except Exception as e:
        return ToolResult.error(f"Operation failed: {e}")

    finally:
        if should_close:
            await session.close()
```

GUARANTEES:
✅ Sessions created internally are always closed
✅ Sessions provided externally are NOT closed (caller's responsibility)
✅ Errors returned as ToolResult.error (existing pattern)
✅ Exception details preserved

=============================================================================
MIGRATION PATH FOR EXISTING CODE
=============================================================================

PHASE 1: Add Infrastructure (Non-Breaking)
-------------------------------------------
- Add Neo4jSessionContext class
- Add session parameter to all methods (optional, default None)
- Add session_context() helper method
- Add database parameter to adapter init

✅ All existing code works unchanged

PHASE 2: Add Batch Methods (Additive)
--------------------------------------
- Create store_memory_batch()
- Create create_commitment_with_context()
- Create other high-value batch methods

✅ All existing code works unchanged
✅ New code can use batch methods for optimization

PHASE 3: Gradual Adoption (Optional)
-------------------------------------
- Update high-traffic code paths to use session context
- Update workflows with multiple operations
- Measure performance improvements

✅ Existing code still works
✅ Performance improves incrementally

PHASE 4: Documentation & Best Practices
----------------------------------------
- Document when to use session reuse
- Document when to use batch transactions
- Provide examples and benchmarks

=============================================================================
PERFORMANCE EXPECTATIONS
=============================================================================

BASELINE (Current):
-------------------
- Session creation overhead: ~1-2ms per session
- Connection from pool: ~0.1ms (driver handles this)
- Network round-trip (no database specified): +1 round-trip
- Transaction overhead: Small but accumulates

HIGH-IMPACT OPTIMIZATION SCENARIOS:
-----------------------------------

Scenario 1: Memory Storage Workflow (spec example)
Current: 4 sessions (vector + decision + entity + links)
Optimized: 1 session
Reduction: 75% fewer sessions
Expected: ~3-6ms saved per memory storage

Scenario 2: Commitment with Context
Current: 2-N sessions (commitment + N links)
Optimized: 1 session
Reduction: 50-90% fewer sessions
Expected: ~1-10ms saved depending on N

Scenario 3: Bulk Entity Creation
Current: N sessions
Optimized: 1 session
Reduction: (N-1)/N * 100%
Expected: Significant for N > 10

ADDITIONAL OPTIMIZATIONS:
-------------------------
- Database parameter: -1 network round-trip per session
- Transaction batching: Reduces transaction overhead
- Causal consistency: Free via session bookmarking

MEASUREMENT PLAN:
-----------------
Phase 4.4 will create benchmarks to measure:
1. Single operation baseline
2. Multi-operation with separate sessions (current)
3. Multi-operation with session reuse (optimized)
4. Multi-operation with transaction batching (atomic)

Target: 50-75% reduction in overhead for multi-operation workflows

=============================================================================
DESIGN RATIONALE SUMMARY
=============================================================================

WHY THIS DESIGN:
----------------

1. BACKWARD COMPATIBLE
   ✅ Zero breaking changes
   ✅ All existing code works unchanged
   ✅ Gradual migration path

2. FLEXIBLE
   ✅ Supports session reuse
   ✅ Supports transaction batching
   ✅ Supports current behavior
   ✅ Caller chooses what they need

3. EXPLICIT & CLEAR
   ✅ No hidden state (vs contextvars)
   ✅ Pythonic patterns
   ✅ Easy to understand and debug

4. SAFE
   ✅ Automatic cleanup via context managers
   ✅ Exception-safe by design
   ✅ No session leaks
   ✅ Proper transaction handling

5. PERFORMANT
   ✅ Reduces session creation overhead
   ✅ Enables transaction batching
   ✅ Eliminates unnecessary round-trips
   ✅ Provides causal consistency

6. FOLLOWS BEST PRACTICES
   ✅ Aligns with Neo4j driver recommendations
   ✅ Uses managed transactions for reliability
   ✅ Supports all Neo4j transaction patterns
   ✅ Properly handles concurrency constraints

RISKS MITIGATED:
----------------
- Session leaks: Context manager ensures cleanup
- Breaking changes: Optional parameters maintain compatibility
- Complexity: Progressive enhancement, simple base case
- Transaction conflicts: Flexible patterns for different needs
- Concurrency issues: Sessions not shared across async tasks

=============================================================================
NEXT PHASE: IMPLEMENTATION
=============================================================================

Subtask 2.1: Create Neo4jSessionContext class
  - Implement async context manager
  - Add support for session and transaction modes
  - Implement cleanup logic
  - Add error handling

Subtask 2.2: Add session pooling to Neo4jAdapter
  - Add database parameter to __init__
  - Create session_context() helper method
  - Update session creation to use database parameter

Subtask 2.3: Implement transaction batching support
  - Add batch_transaction mode to context manager
  - Test atomic guarantees
  - Verify rollback behavior

=============================================================================

=============================================================================
PHASE 2: CORE SESSION POOL IMPLEMENTATION
=============================================================================

Subtask 2.1: Create Neo4jSessionContext class
Status: COMPLETED
Date: 2026-01-11

=============================================================================
NEO4JSESSIONCONTEXT IMPLEMENTATION
=============================================================================

IMPLEMENTATION SUMMARY
----------------------
Successfully implemented Neo4jSessionContext as an async context manager
class for managing Neo4j session lifecycle with support for both session
reuse and transaction batching patterns.

KEY FEATURES IMPLEMENTED
-------------------------

1. ASYNC CONTEXT MANAGER PROTOCOL
   ✅ __aenter__ method
      - Creates session with database parameter specified
      - Begins explicit transaction if batch_transaction=True
      - Returns session or transaction based on mode

   ✅ __aexit__ method
      - Commits transaction on success (no exception)
      - Rolls back transaction on error (exception occurred)
      - Always closes session in finally block
      - Returns False to propagate exceptions

2. CONSTRUCTOR
   ✅ Parameters:
      - adapter: Neo4jAdapter instance (required)
      - database: str = "neo4j" (optimizes performance)
      - batch_transaction: bool = False (enables atomic batching)

   ✅ Instance variables:
      - _adapter: Reference to adapter
      - _database: Database name for session creation
      - _batch_transaction: Transaction mode flag
      - _session: Session instance (set in __aenter__)
      - _transaction: Transaction instance (set if batch mode)

3. NEO4JADAPTER ENHANCEMENTS
   ✅ Database parameter added to __init__
      - Optional parameter with env var fallback
      - Defaults to NEO4J_DATABASE env var or "neo4j"
      - Stored as self._database

   ✅ session_context() helper method
      - Easy-to-use factory method
      - Accepts batch_transaction parameter
      - Returns Neo4jSessionContext instance
      - Comprehensive docstring with examples

USAGE PATTERNS SUPPORTED
-------------------------

Pattern A: Session Reuse (Multiple Independent Transactions)
```python
async with adapter.session_context() as session:
    # Each operation is separate transaction
    await adapter._create_entity(entity_data, session=session)
    await adapter._link_nodes(link_data, session=session)
    await adapter._get_entity_context(query_data, session=session)

# Session automatically closed, even on error
```

Pattern B: Atomic Batch (Single Transaction)
```python
async with adapter.session_context(batch_transaction=True) as tx:
    # All operations in single atomic transaction
    await adapter._create_entity(entity_data, session=tx)
    await adapter._link_nodes(link_data, session=tx)
    # If any operation fails, entire batch rolls back

# Transaction committed if successful, rolled back on error
```

ERROR HANDLING
--------------
✅ Exception-safe cleanup
   - finally block ensures session always closed
   - Proper transaction rollback on errors
   - Exceptions propagate to caller (not suppressed)

✅ Resource guarantees
   - No session leaks
   - Connections returned to driver pool
   - Transaction state properly managed

PERFORMANCE OPTIMIZATIONS
--------------------------
✅ Database parameter optimization
   - Eliminates extra round-trip to server
   - Per Neo4j docs: "If no database is provided, the driver has to send
     an extra request to the server to figure out what the default database is"
   - Saves ~1 network round-trip per session creation

✅ Session reuse foundation
   - Enables multiple operations in one session
   - Reduces session creation overhead
   - Provides causal consistency via bookmarking

CODE QUALITY
------------
✅ No syntax errors (verified with py_compile)
✅ Comprehensive documentation
✅ Clear usage examples in docstrings
✅ Follows Neo4j driver best practices
✅ Aligns with design specification from subtask 1.3

VERIFICATION RESULTS
--------------------
✅ Class structure complete
✅ Async context manager protocol implemented
✅ Both transaction modes supported
✅ Error handling comprehensive
✅ Database parameter configured
✅ Helper method added to adapter
✅ Documentation complete

FILES MODIFIED
--------------
- Tools/adapters/neo4j_adapter.py
  * Added Neo4jSessionContext class (lines 51-120)
  * Enhanced Neo4jAdapter.__init__ with database parameter (line 231)
  * Added session_context() helper method (lines 266-291)

NEXT STEPS
----------
Subtask 2.1 is COMPLETE. The async context manager is ready for use.

However, to make it fully useful, we need to proceed to subtask 2.2 which
will add optional session parameters to all Neo4j adapter methods. This will
allow methods to accept and reuse sessions from the context manager.

Note: Subtask 2.2 as originally defined focused on "session pool management"
but based on the design, it should actually focus on adding optional session
parameters to all adapter methods. Subtask 2.3 can remain focused on
transaction batching patterns and batch operation methods.

=============================================================================
